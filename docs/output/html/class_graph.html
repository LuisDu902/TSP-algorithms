<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSP: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TSP
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Unidade Curricular DA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a619ac583094079134074658e29463c0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a619ac583094079134074658e29463c0e">getVertexSet</a> () const</td></tr>
<tr class="separator:a619ac583094079134074658e29463c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f7fc73ea9976295d387846ad36c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a089f7fc73ea9976295d387846ad36c69">findVertex</a> (const int &amp;id) const</td></tr>
<tr class="memdesc:a089f7fc73ea9976295d387846ad36c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns a vertex in the graph based on the provided ID.  <a href="class_graph.html#a089f7fc73ea9976295d387846ad36c69">More...</a><br /></td></tr>
<tr class="separator:a089f7fc73ea9976295d387846ad36c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b24d74e2137767dab58d018a2813ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a10b24d74e2137767dab58d018a2813ef">addVertex</a> (const int &amp;id, const double &amp;longitude=0, const double &amp;latitude=0)</td></tr>
<tr class="memdesc:a10b24d74e2137767dab58d018a2813ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new vertex to the graph with the specified ID, longitude, and latitude.  <a href="class_graph.html#a10b24d74e2137767dab58d018a2813ef">More...</a><br /></td></tr>
<tr class="separator:a10b24d74e2137767dab58d018a2813ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d587225dac1db0874dabe5fab50628c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6d587225dac1db0874dabe5fab50628c">addEdge</a> (<a class="el" href="class_vertex.html">Vertex</a> *&amp;v1, <a class="el" href="class_vertex.html">Vertex</a> *&amp;v2, double <a class="el" href="class_graph.html#ae1903ac67f05cd9c9874fd63295cb80e">distance</a>) const</td></tr>
<tr class="memdesc:a6d587225dac1db0874dabe5fab50628c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge between two vertexes in the graph with the specified distance.  <a href="class_graph.html#a6d587225dac1db0874dabe5fab50628c">More...</a><br /></td></tr>
<tr class="separator:a6d587225dac1db0874dabe5fab50628c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc561903a10e7760feb78e325040023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1fc561903a10e7760feb78e325040023">tspBT</a> (std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;bestPath, double &amp;minDist)</td></tr>
<tr class="memdesc:a1fc561903a10e7760feb78e325040023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem (TSP) using backtracking.  <a href="class_graph.html#a1fc561903a10e7760feb78e325040023">More...</a><br /></td></tr>
<tr class="separator:a1fc561903a10e7760feb78e325040023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d65eed58f15a6680954aebc086f230a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8d65eed58f15a6680954aebc086f230a">triangularApproximation</a> (std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;tour, double &amp;dist)</td></tr>
<tr class="memdesc:a8d65eed58f15a6680954aebc086f230a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem (TSP) using triangular approximation algorithm.  <a href="class_graph.html#a8d65eed58f15a6680954aebc086f230a">More...</a><br /></td></tr>
<tr class="separator:a8d65eed58f15a6680954aebc086f230a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90dbd43f050b34907c4dfb47e548969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa90dbd43f050b34907c4dfb47e548969">nearestNeighborTSP</a> (std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;tour, double &amp;<a class="el" href="class_graph.html#ae1903ac67f05cd9c9874fd63295cb80e">distance</a>)</td></tr>
<tr class="memdesc:aa90dbd43f050b34907c4dfb47e548969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem (TSP) using nearest neighbor algorithm.  <a href="class_graph.html#aa90dbd43f050b34907c4dfb47e548969">More...</a><br /></td></tr>
<tr class="separator:aa90dbd43f050b34907c4dfb47e548969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289b0aa65c318963a70d0ae6271fa33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa289b0aa65c318963a70d0ae6271fa33">christofidesTSP</a> (std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;tour, double &amp;<a class="el" href="class_graph.html#ae1903ac67f05cd9c9874fd63295cb80e">distance</a>)</td></tr>
<tr class="memdesc:aa289b0aa65c318963a70d0ae6271fa33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem (TSP) using christofides algorithm combined with 2-opt.  <a href="class_graph.html#aa289b0aa65c318963a70d0ae6271fa33">More...</a><br /></td></tr>
<tr class="separator:aa289b0aa65c318963a70d0ae6271fa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae060553e7aac3bd1ae845db31c939280"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae060553e7aac3bd1ae845db31c939280">savePath</a> (<a class="el" href="class_vertex.html">Vertex</a> *v1)</td></tr>
<tr class="memdesc:ae060553e7aac3bd1ae845db31c939280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the path from a specified vertex to the source vertex as a stack of vertex IDs.  <a href="class_graph.html#ae060553e7aac3bd1ae845db31c939280">More...</a><br /></td></tr>
<tr class="separator:ae060553e7aac3bd1ae845db31c939280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2840f964081ecb3c6ee250196e567e13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2840f964081ecb3c6ee250196e567e13">tspBTRec</a> (int curVertex, int curIndex, double &amp;minDist, std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;bestPath)</td></tr>
<tr class="memdesc:a2840f964081ecb3c6ee250196e567e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function for the TSP backtracking algorithm.  <a href="class_graph.html#a2840f964081ecb3c6ee250196e567e13">More...</a><br /></td></tr>
<tr class="separator:a2840f964081ecb3c6ee250196e567e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb18a1f9d2ad51214d4211d60edf6860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acb18a1f9d2ad51214d4211d60edf6860">prim</a> ()</td></tr>
<tr class="memdesc:acb18a1f9d2ad51214d4211d60edf6860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies Prim's algorithm to find a minimum spanning tree in the graph.  <a href="class_graph.html#acb18a1f9d2ad51214d4211d60edf6860">More...</a><br /></td></tr>
<tr class="separator:acb18a1f9d2ad51214d4211d60edf6860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0db3dbf1368e972e7c551f6084db62"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8b0db3dbf1368e972e7c551f6084db62">haversine</a> (double lat1, double lon1, double lat2, double lon2)</td></tr>
<tr class="memdesc:a8b0db3dbf1368e972e7c551f6084db62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance between two vertexes using the Haversine formula.  <a href="class_graph.html#a8b0db3dbf1368e972e7c551f6084db62">More...</a><br /></td></tr>
<tr class="separator:a8b0db3dbf1368e972e7c551f6084db62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46abbf3654aa869d2a6c9620ebbbad30"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a46abbf3654aa869d2a6c9620ebbbad30">preOrderTraversal</a> ()</td></tr>
<tr class="memdesc:a46abbf3654aa869d2a6c9620ebbbad30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a pre-order traversal of the minimum spanning tree rooted at 0.  <a href="class_graph.html#a46abbf3654aa869d2a6c9620ebbbad30">More...</a><br /></td></tr>
<tr class="separator:a46abbf3654aa869d2a6c9620ebbbad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aff798439dd450d7ac8eba1c8458e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3aff798439dd450d7ac8eba1c8458e65">preOrder</a> (<a class="el" href="class_vertex.html">Vertex</a> *vertex, std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;l)</td></tr>
<tr class="memdesc:a3aff798439dd450d7ac8eba1c8458e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a pre-order traversal of the minimum spanning tree rooted at 0.  <a href="class_graph.html#a3aff798439dd450d7ac8eba1c8458e65">More...</a><br /></td></tr>
<tr class="separator:a3aff798439dd450d7ac8eba1c8458e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1903ac67f05cd9c9874fd63295cb80e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae1903ac67f05cd9c9874fd63295cb80e">distance</a> (<a class="el" href="class_vertex.html">Vertex</a> *v1, <a class="el" href="class_vertex.html">Vertex</a> *v2)</td></tr>
<tr class="memdesc:ae1903ac67f05cd9c9874fd63295cb80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance between two vertexes in the graph.  <a href="class_graph.html#ae1903ac67f05cd9c9874fd63295cb80e">More...</a><br /></td></tr>
<tr class="separator:ae1903ac67f05cd9c9874fd63295cb80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfff09df8a7409142697d167eff892d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2cfff09df8a7409142697d167eff892d">updateMst</a> (<a class="el" href="class_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:a2cfff09df8a7409142697d167eff892d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the minimum spanning tree (MST) when a new edge is added.  <a href="class_graph.html#a2cfff09df8a7409142697d167eff892d">More...</a><br /></td></tr>
<tr class="separator:a2cfff09df8a7409142697d167eff892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632ee9309f0938138dbb6c43d2cbfded"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a632ee9309f0938138dbb6c43d2cbfded">oddDegreeVertexes</a> ()</td></tr>
<tr class="memdesc:a632ee9309f0938138dbb6c43d2cbfded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the set of vertexes with an odd degree in the mst.  <a href="class_graph.html#a632ee9309f0938138dbb6c43d2cbfded">More...</a><br /></td></tr>
<tr class="separator:a632ee9309f0938138dbb6c43d2cbfded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4e9734184d843d24f417b0af1c1d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aee4e9734184d843d24f417b0af1c1d4b">perfectMatching</a> (const std::unordered_set&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;oddVertexes)</td></tr>
<tr class="memdesc:aee4e9734184d843d24f417b0af1c1d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a perfect matching among the odd-degree vertexes in the mst using a greedy algorithm.  <a href="class_graph.html#aee4e9734184d843d24f417b0af1c1d4b">More...</a><br /></td></tr>
<tr class="separator:aee4e9734184d843d24f417b0af1c1d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d0a2fcea003aed540efd2262228e96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a78d0a2fcea003aed540efd2262228e96">matchVertexes</a> (<a class="el" href="class_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:a78d0a2fcea003aed540efd2262228e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches two vertexes by adding corresponding edges between them.  <a href="class_graph.html#a78d0a2fcea003aed540efd2262228e96">More...</a><br /></td></tr>
<tr class="separator:a78d0a2fcea003aed540efd2262228e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360f287c9c5c634382b4b3cf15314c1"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9360f287c9c5c634382b4b3cf15314c1">eulerianCircuit</a> ()</td></tr>
<tr class="memdesc:a9360f287c9c5c634382b4b3cf15314c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an Eulerian circuit in the graph using Hierholzer's algorithm.  <a href="class_graph.html#a9360f287c9c5c634382b4b3cf15314c1">More...</a><br /></td></tr>
<tr class="separator:a9360f287c9c5c634382b4b3cf15314c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9110f474904cdf9be5b820398edfc96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab9110f474904cdf9be5b820398edfc96">heirholzer</a> (<a class="el" href="class_vertex.html">Vertex</a> *v, std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;circuit)</td></tr>
<tr class="memdesc:ab9110f474904cdf9be5b820398edfc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively performs Hierholzer's algorithm to construct an Eulerian circuit in the graph.  <a href="class_graph.html#ab9110f474904cdf9be5b820398edfc96">More...</a><br /></td></tr>
<tr class="separator:ab9110f474904cdf9be5b820398edfc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7447fad7c8ca44b830a25caec2b4209"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac7447fad7c8ca44b830a25caec2b4209">hamiltonianCycle</a> (std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; circuit)</td></tr>
<tr class="memdesc:ac7447fad7c8ca44b830a25caec2b4209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a Hamiltonian cycle from an Eulerian circuit.  <a href="class_graph.html#ac7447fad7c8ca44b830a25caec2b4209">More...</a><br /></td></tr>
<tr class="separator:ac7447fad7c8ca44b830a25caec2b4209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423fdb7e34dc52cea2a8fc63c9196c82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a423fdb7e34dc52cea2a8fc63c9196c82">twoOpt</a> (std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;tour, double &amp;dist)</td></tr>
<tr class="memdesc:a423fdb7e34dc52cea2a8fc63c9196c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the 2-opt optimization heuristic to improve a tour by removing intersecting edges.  <a href="class_graph.html#a423fdb7e34dc52cea2a8fc63c9196c82">More...</a><br /></td></tr>
<tr class="separator:a423fdb7e34dc52cea2a8fc63c9196c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa9b0a6d8ad43c5eabaca5a7140bcc8b6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa9b0a6d8ad43c5eabaca5a7140bcc8b6">vertexSet</a></td></tr>
<tr class="separator:aa9b0a6d8ad43c5eabaca5a7140bcc8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6d587225dac1db0874dabe5fab50628c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d587225dac1db0874dabe5fab50628c">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an edge between two vertexes in the graph with the specified distance. </p>
<p>This function adds an edge between the two provided vertexes with the specified distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>A pointer to the first vertex of the edge. </td></tr>
    <tr><td class="paramname">v2</td><td>A pointer to the second vertex of the edge. </td></tr>
    <tr><td class="paramname">distance</td><td>The distance of the edge between the two vertexes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a10b24d74e2137767dab58d018a2813ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b24d74e2137767dab58d018a2813ef">&#9670;&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>longitude</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>latitude</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new vertex to the graph with the specified ID, longitude, and latitude. </p>
<p>This function creates a new vertex object with the provided ID, longitude, and latitude, and adds it to the graph's vertex set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the vertex to find. </td></tr>
    <tr><td class="paramname">longitude</td><td>The longitude coordinate of the vertex (default value: 0). </td></tr>
    <tr><td class="paramname">latitude</td><td>The latitude coordinate of the vertex (default value: 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="aa289b0aa65c318963a70d0ae6271fa33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa289b0aa65c318963a70d0ae6271fa33">&#9670;&nbsp;</a></span>christofidesTSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::christofidesTSP </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem (TSP) using christofides algorithm combined with 2-opt. </p>
<p>This function applies the christofides algorithm to the graph, which consists in:<br  />
</p><pre><b>(1)</b> Constructing a minimum spanning tree (MST) of the graph using Prim's algorithm.</pre> <pre><b>(2)</b> Identifying the vertexes with odd degrees in the MST.</pre> <pre><b>(3)</b> Constructing a minimum-weight perfect matching among the odd-degree vertexes.</pre> <pre><b>(4)</b> Computing an Eulerian circuit in the graph by combining the MST edges and matching edges.</pre> <pre><b>(5)</b> Obtaining a Hamiltonian cycle by removing duplicate vertexes from the circuit.</pre> <pre><b>(6)</b> Improving the tour using the 2-opt optimization algorithm.</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tour</td><td>The vector to store the resulting tour. </td></tr>
    <tr><td class="paramname">distance</td><td>The reference variable to accumulate the total distance of the tour.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E * log(V)), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="ae1903ac67f05cd9c9874fd63295cb80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1903ac67f05cd9c9874fd63295cb80e">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the distance between two vertexes in the graph. </p>
<p>The function first checks if there is an edge between the two vertexes. If an edge is found, the distance is retrieved from the edge. If there is no direct edge, the function calculates the distance using the haversine formula.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Pointer to the first vertex. </td></tr>
    <tr><td class="paramname">v2</td><td>Pointer to the second vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the two vertexes.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(n), where n is the number of adjacent edges of vertex v1. </dd></dl>

</div>
</div>
<a id="a9360f287c9c5c634382b4b3cf15314c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9360f287c9c5c634382b4b3cf15314c1">&#9670;&nbsp;</a></span>eulerianCircuit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::eulerianCircuit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an Eulerian circuit in the graph using Hierholzer's algorithm. </p>
<p>The function computes an eulerian circuit using Hierholzer's algorithm.</p>
<dl class="section return"><dt>Returns</dt><dd>A stack of vertexes representing the Eulerian circuit in the graph.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E), where E is the number of edges in the graph </dd></dl>

</div>
</div>
<a id="a089f7fc73ea9976295d387846ad36c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f7fc73ea9976295d387846ad36c69">&#9670;&nbsp;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and returns a vertex in the graph based on the provided ID. </p>
<p>This function searches for a vertex with the specified ID in the graph's vertex set and returns a pointer to the found vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the vertex to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found vertex if it exists, or nullptr if the vertex is not found.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V), where V the number of vertexes in the graph. </dd></dl>

</div>
</div>
<a id="a619ac583094079134074658e29463c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619ac583094079134074658e29463c0e">&#9670;&nbsp;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::getVertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7447fad7c8ca44b830a25caec2b4209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7447fad7c8ca44b830a25caec2b4209">&#9670;&nbsp;</a></span>hamiltonianCycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::hamiltonianCycle </td>
          <td>(</td>
          <td class="paramtype">std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td>
          <td class="paramname"><em>circuit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a Hamiltonian cycle from an Eulerian circuit. </p>
<p>This function computes a Hamiltonian cycle from an Eulerian circuit, by ignoring the repeated vertexes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The stack representing an Eulerian circuit in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vertexes representing a Hamiltonian cycle in the graph.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V), where V is the number of vertexes in the graph </dd></dl>

</div>
</div>
<a id="a8b0db3dbf1368e972e7c551f6084db62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0db3dbf1368e972e7c551f6084db62">&#9670;&nbsp;</a></span>haversine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::haversine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the distance between two vertexes using the Haversine formula. </p>
<p>The Haversine formula is used to compute the great-circle distance between two points given their latitude and longitude coordinates. The function takes the latitude and longitude of the two points (vertexes) as parameters and returns the distance between them in meters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1</td><td>Latitude of the first vertex. </td></tr>
    <tr><td class="paramname">lon1</td><td>Longitude of the first vertex. </td></tr>
    <tr><td class="paramname">lat2</td><td>Latitude of the second vertex. </td></tr>
    <tr><td class="paramname">lon2</td><td>Longitude of the second vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the two vertex in meters.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="ab9110f474904cdf9be5b820398edfc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9110f474904cdf9be5b820398edfc96">&#9670;&nbsp;</a></span>heirholzer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::heirholzer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>circuit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively performs Hierholzer's algorithm to construct an Eulerian circuit in the graph. </p>
<p>This function iterates through the adjacency list of vertex <code>v</code> and selects each unvisited edge and its reverse edge. For each selected edge, it marks the edges as visited. Then, the function recursively calls itself on the destination vertex of the selected edge. This process continues until all edges have been visited. Finally, it pushes the current vertex <code>v</code> onto the stack <code>circuit</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The current vertex in the recursive step of Hierholzer's algorithm. </td></tr>
    <tr><td class="paramname">circuit</td><td>The stack to store the vertexes in the Eulerian circuit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E), where E is the number of edges in the graph </dd></dl>

</div>
</div>
<a id="a78d0a2fcea003aed540efd2262228e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d0a2fcea003aed540efd2262228e96">&#9670;&nbsp;</a></span>matchVertexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::matchVertexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches two vertexes by adding corresponding edges between them. </p>
<p>This function matches two odd-degree vertexes by adding a bidirectional edge to connect them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The edge connecting the two vertexes to be matched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="aa90dbd43f050b34907c4dfb47e548969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90dbd43f050b34907c4dfb47e548969">&#9670;&nbsp;</a></span>nearestNeighborTSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::nearestNeighborTSP </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem (TSP) using nearest neighbor algorithm. </p>
<p>This function applies the nearest neighbor algorithm to the graph, which consists in:<br  />
</p><pre><b>(1)</b> Initializing all vertexes as unvisited.</pre> <pre><b>(2)</b> Selecting the first vertex, setting it as the current vertex. Mark it as visited.</pre> <pre><b>(3)</b> Finding out the shortest edge connecting the current vertex u and an unvisited vertex v.</pre> <pre><b>(4)</b> Setting v as the current vertex. Mark v as visited.</pre> <pre><b>(5)</b> Repeating steps 3 and 4 until all the vertexes are visited.</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tour</td><td>The vector to store the resulting tour. </td></tr>
    <tr><td class="paramname">distance</td><td>The reference variable to accumulate the total distance of the tour.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E + V), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a632ee9309f0938138dbb6c43d2cbfded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632ee9309f0938138dbb6c43d2cbfded">&#9670;&nbsp;</a></span>oddDegreeVertexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::oddDegreeVertexes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the set of vertexes with an odd degree in the mst. </p>
<p>The function iterates over each vertex in the <code>vertexSet</code> and checks if its degree is odd. If a vertex has an odd degree, it is added to the <code>oddVertexes</code> set. Finally, the function returns the set of vertexes with odd degrees.</p>
<dl class="section return"><dt>Returns</dt><dd>An unordered set of vertexes with odd degrees.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V), where V is the number of vertexes in the graph. </dd></dl>

</div>
</div>
<a id="aee4e9734184d843d24f417b0af1c1d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4e9734184d843d24f417b0af1c1d4b">&#9670;&nbsp;</a></span>perfectMatching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::perfectMatching </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>oddVertexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a perfect matching among the odd-degree vertexes in the mst using a greedy algorithm. </p>
<p>The function performs a perfect matching among all the odd-degree vertexes in the mst using a greedy algorithm. Firstly, all the edges that connect odd-degree vertexes are sorted in ascending order based on their distance. It then iteratively selects the lightest weight edge from the sorted set and matches two unmatched vertexes until all vertexes are matched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oddVertexes</td><td>An unordered set of odd-degree vertexes to be matched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E * log(E)), where E is the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a3aff798439dd450d7ac8eba1c8458e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aff798439dd450d7ac8eba1c8458e65">&#9670;&nbsp;</a></span>preOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::preOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a pre-order traversal of the minimum spanning tree rooted at 0. </p>
<p>The function recursively traverses the minimum spanning tree rooted at 0 in pre-order. It adds each visited vertex to the <code>l</code> queue, indicating the order of traversal. The function performs the traversal using a depth-first search algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Pointer to the root vertex of the minimum spanning tree. </td></tr>
    <tr><td class="paramname">l</td><td>Reference to the queue used to store the order of traversal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V), where V is the number of vertexes in the graph. </dd></dl>

</div>
</div>
<a id="a46abbf3654aa869d2a6c9620ebbbad30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46abbf3654aa869d2a6c9620ebbbad30">&#9670;&nbsp;</a></span>preOrderTraversal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::preOrderTraversal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a pre-order traversal of the minimum spanning tree rooted at 0. </p>
<p>The function performs a pre-order traversal of the minimum spanning tree rooted at 0, using a depth-first search algorithm.</p>
<dl class="section return"><dt>Returns</dt><dd>A queue containing the vertexes in the order of pre-order traversal.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V), where V is the number of vertexes in the graph. </dd></dl>

</div>
</div>
<a id="acb18a1f9d2ad51214d4211d60edf6860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb18a1f9d2ad51214d4211d60edf6860">&#9670;&nbsp;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::prim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies Prim's algorithm to find a minimum spanning tree in the graph. </p>
<p>This function applies Prim's algorithm to the graph, starting from the first vertex in the vertexSet. It initializes the necessary data structures and maintains a priority queue to track the minimum path costs. The minimum spanning tree is constructed by iteratively adding the minimum cost edges.</p>
<dl class="section user"><dt>Time complexity</dt><dd>O(E * log(V)), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="ae060553e7aac3bd1ae845db31c939280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae060553e7aac3bd1ae845db31c939280">&#9670;&nbsp;</a></span>savePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::savePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the path from a specified vertex to the source vertex as a stack of vertex IDs. </p>
<p>This function traverses the path from the specified vertex to the source vertex and saves the vertexes in a stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>A pointer to the vertex from which to start traversing the path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stack of vertexes representing the path.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(n), where n is the length of the path from the specified vertex to the source vertex. </dd></dl>

</div>
</div>
<a id="a8d65eed58f15a6680954aebc086f230a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d65eed58f15a6680954aebc086f230a">&#9670;&nbsp;</a></span>triangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::triangularApproximation </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem (TSP) using triangular approximation algorithm. </p>
<p>This function applies the triangular approximation algorithm to the graph, which consists in :<br  />
</p><pre><b>(1)</b> Constructing a minimum spanning tree (MST) of the graph using Prim's algorithm.</pre> <pre><b>(2)</b> Traversing the tree using a pre-order traversal.</pre> <pre><b>(3)</b> Computing a Hamiltonian cycle that visits all vertexes exactly once based on the pre-order.</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tour</td><td>The queue to store the resulting tour. </td></tr>
    <tr><td class="paramname">dist</td><td>The reference variable to accumulate the total distance of the tour.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E * log(V)), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a1fc561903a10e7760feb78e325040023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc561903a10e7760feb78e325040023">&#9670;&nbsp;</a></span>tspBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspBT </td>
          <td>(</td>
          <td class="paramtype">std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem (TSP) using backtracking. </p>
<p>This function applies the backtracking algorithm to solve the TSP on the graph. It finds the shortest Hamiltonian cycle that visits all vertexes exactly once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bestPath</td><td>Stack that will store the vertexes of the best path found. </td></tr>
    <tr><td class="paramname">minDist</td><td>Minimum distance of the best path found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V!), where V is the number of vertexes in the graph. </dd></dl>

</div>
</div>
<a id="a2840f964081ecb3c6ee250196e567e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2840f964081ecb3c6ee250196e567e13">&#9670;&nbsp;</a></span>tspBTRec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspBTRec </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>curVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>curIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive function for the TSP backtracking algorithm. </p>
<p>This function is called recursively to explore all possible paths and find the best Hamiltonian cycle. It uses backtracking to prune unnecessary branches based on the current minimum distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curVertex</td><td>The ID of the current vertex being visited. </td></tr>
    <tr><td class="paramname">curIndex</td><td>The index of the current vertex in the path. </td></tr>
    <tr><td class="paramname">minDist</td><td>The minimum distance found so far. </td></tr>
    <tr><td class="paramname">bestPath</td><td>The stack that stores the vertexes of the best path found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V!), where V is the number of vertexes in the graph. </dd></dl>

</div>
</div>
<a id="a423fdb7e34dc52cea2a8fc63c9196c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423fdb7e34dc52cea2a8fc63c9196c82">&#9670;&nbsp;</a></span>twoOpt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::twoOpt </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the 2-opt optimization heuristic to improve a tour by removing intersecting edges. </p>
<p>This function applies the 2-opt optimization heuristic to improve a given tour. It iteratively takes 2 edges from the tour, reconnect these edges with each other and calculate new travel distance. If this modification has led to a shorter total travel distance the current route is updated. The algorithm continues to build on the improved route and repeats the steps until the tour in optimal or the maximum number of iterations has been reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tour</td><td>The vector representing the tour to be optimized. </td></tr>
    <tr><td class="paramname">dist</td><td>The initial distance of the tour, which will be updated with the improved distance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V³), where V is the number of vertexes in the graph </dd></dl>

</div>
</div>
<a id="a2cfff09df8a7409142697d167eff892d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfff09df8a7409142697d167eff892d">&#9670;&nbsp;</a></span>updateMst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::updateMst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the minimum spanning tree (MST) when a new edge is added. </p>
<p>The function updates the MST by adding two new MST edges between the vertex <code>v</code> and its predecessor vertex <code>w</code> in the MST .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the new vertex added to the MST.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(1) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa9b0a6d8ad43c5eabaca5a7140bcc8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b0a6d8ad43c5eabaca5a7140bcc8b6">&#9670;&nbsp;</a></span>vertexSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_vertex.html">Vertex</a> *&gt; Graph::vertexSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/luisdu/CLionProjects/feup-da-proj2/code/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>/home/luisdu/CLionProjects/feup-da-proj2/code/<a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
